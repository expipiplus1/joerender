float3 red; // this is given as a uniform
float3 green = float3(0.44, 0.85, 0.29);
float3 blue  = float3(0.49, 0.65, 0.85);
float3 black = float3(0,0,0);

//
// Get a color based on a string
//
float3 GetColor( const string color_string )
{
    return color_string == "blue"  ? blue  :
           color_string == "red"   ? red   :
           color_string == "green" ? green :
           black;
}

in varying float4 position : POSITION;

in varying float4 wpos : WPOS;

uniform float3x3 rotate;

float4 VertexMain( float4 mul ) : POSITION
{
    return float4( mul( rotate, position.xyz ), 1) * mul;
}

float2 WindowPosition()
{
    return wpos.xy / float2(640,480);
}

float3 white = 1;

float3 pink = (green + white)/2..xxx;
float3 purple;

float4 zero = float4(0);
float4 one  = float4(1..xx, 1, 1.);

float4 PixelMain( bool b ) : COLOR
{
    return float4( b ? red : blue, 0.5 );
}

const float4 default_offset = float4(0,0,0,0);

technique clear_blue
{
    pass clear
    {
        clear_color = float4( pink, 0 );
        clear = COLOR;
    }
    pass first_triangle
    {
        pixel_shader = compile PixelMain( true );
        vertex_shader = compile VertexMain( float4(1,1,1,1) );

        render_scene = true;
    }
    pass second_triangle
    {
        //
        // Blend this additively
        //
        blend_enable = true;
        blend_equation = ADD;
        blend_func = uint2(SRC_ALPHA, ONE_MINUS_SRC_ALPHA);

        pixel_shader = compile PixelMain( false );
        // flip this triangle in x
        vertex_shader = compile VertexMain( float4(-1,1,1,1) );

        render_scene = true;
    }
    pass matrix_state
    {
        //matrix_state = float4x4( zero, one, zero, one );
    }
}
