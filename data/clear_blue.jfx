float3 red; // this is given as a uniform
float3 green = float3(0.44, 0.85, 0.29);
float3 blue  = float3(0.49, 0.65, 0.85);
float3 black = float3(0,0,0);

//
// Get a color based on a string
//
float3 GetColor( const string color_string )
{
    return color_string == "blue"  ? blue  :
           color_string == "red"   ? red   :
           color_string == "green" ? green :
           black;
}

in varying float4 position : POSITION;

in varying float4 wpos : WPOS;

//uniform bool b;

float4 VertexMain( float4 mul ) : POSITION
{
    return position * mul;
}

float2 WindowPosition()
{
    return wpos.xy / float2(640,480);
}

float4 PixelMain( bool b ) : COLOR
{
    //return float4( red, 1 );
    return float4( (b ? green : red), 1 );
}

const float4 default_offset = float4(0,0,0,0);

technique clear_blue
{
    pass clear
    {
        clear_color = float4(blue,0);
        clear = COLOR;
    }
    pass first_triangle
    {
        pixel_shader = compile PixelMain( true );
        vertex_shader = compile VertexMain( float4(1,1,1,1) );

        render_scene = true;
    }
    pass second_triangle
    {
        //
        // Blend this additively
        //
        blend_enable = true;
        blend_equation = ADD;
        blend_func = uint2(SRC_ALPHA, DST_ALPHA);

        pixel_shader = compile PixelMain( false );
        // flip this triangle in x
        vertex_shader = compile VertexMain( float4(-1,1,1,1) );

        render_scene = true;
    }
}
